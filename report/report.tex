\documentclass{article}

\usepackage[english]{babel}

\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{natbib}
\bibliographystyle{alpha}
\usepackage{caption}
\usepackage{float}

\title{Sistemas Operacionais \\ \large Trabalho Prático 2}
\author{Luís Felipe Ramos Ferreira}
\date{\href{mailto:lframos\_ferreira@outlook.com}{\texttt{lframos\_ferreira@outlook.com}}
}

\begin{document}

\maketitle

\section{Introdução}

O Trabalho Prático 2 da disciplina de Sistemas operacionais teve como proposta
o estudo e modificação dos algoritmos de escalonamento de processos presente
no \textit{kernel} do sistema operacional
\href{https://github.com/mit-pdos/xv6-public}{XV6}.

O repositório onde está armazenado o código utilizado durante o desenvolvimento
desse projeto
pode ser encontrado \href{https://github.com/lframosferreira/tp2-so}{neste
      endereço}.

\section{Respostas}

\begin{enumerate}
      \item Qual a política de escalonamento é utilizada atualmente no XV6?

            A política de escalonamento utilizada no XV6 é uma política de

            \href{https://en.wikipedia.org/wiki/Round-robin_scheduling}{\textit{Round
                        Robin}} sem prioridades, ou seja, o escalonador irá
            checar
            continuamente a lista de processos disponíveis para serem
            executados e irá
            fornecer um tempo de processamento a cada um deles, sem que exista
            uma política de priorização dentre um processo a outro. O algoritmo
            é
            simples de se implementar, simples de compreender e não causa
            inanição aos
            processos, embora possua pontos negativos como os gargalos causados
            pela
            constante troca de contexto, a depender do tempo que cada processo
            terá para
            execução na CPU. É um algoritmo preemptivo, uma vez que força a
            saída de um processo da CPU caso o limite de tempo tenha sido
            atingido.\@

      \item Quais processos essa política seleciona para rodar?

            A política citada seleciona os processos que estão disponíveis para
            serem executados conforme eles são checados na lista de processos
            disponíveis.
            Não há um tipo de prioridade estabelecida em cima sobre os
            processos, ou seja, os processos terão uma certa quantidade de
            tempo a cada
            momento que o escalonador encontrá-los na lista de processos
            disponíveis. É
            importante frisar que o escalonador irá checar \texttt{apenas} os
            processos marcados como disponíveis para serem executados, ou seja,
            processos dormindo ou esperando algum I/O não receberão tempo de
            processamento
            da CPU a menos que estejam prontos para serem executados e marcados
            como tal na
            lista de processos do sistema.

      \item O que acontece quando um processo retorna de uma tarefa de I/O?

            O processo é marcado como \textit{RUNNABLE}, isto é, está pronto
            para executar e entra para a lista de processos que podem ser
            executados.
            Assim, ele eventualmente será escolhido pelo escalonador para
            começar a rodar.

      \item O que acontece quando um processo é criado e quando ou quão
            frequente o escalonamento acontece?

            Quando um processo é criado, uma referência para ele é
            criada no espaço de memória do sistema operacional, e a esse
            processo deve ser alocado um espaço de memória de
            usuário onde irá
            estar armazenado seu identificador, código, dados, pilha de
            execução e \textit{heap}. Um processo pode ser criado no XV6 por
            meio da chamada de sistema \textit{fork()}, que irá criar uma cópia
            do processo que fez a chamada da função. Para executar um novo
            programa, a chamada
            de sistema
            \textit{exec()}
            deve ser utilizada.

            O processo de escalonamento acontece, na implementação original do
            XV6, a cada 1 tick do clock. No entanto, esse parâmetro pode ser
            modificado
            para alterar o período entre as preempções realizadas pelo
            escalonador.

\end{enumerate}

\section{Algoritmos implementados}

\subsection{Escalonador}

Uma das requisições do trabalho foi a de implementar uma modificação na
política de escalonamento do \textit{kernel} do XV6. Em particular, foi
proposta a implementação de um escalonamento por meio de filas multinível. Para
isso, a função
\textit{scheduler()} do arquivo \textit{proc.c} foi alterada de modo a
satisfazer essa política. Em suma, a nova implementação agora irá
checar toda a lista de processos em busca daquele processo que possui a maior
prioridade e, ao fim da busca, esse processo será o próximo a ser executado.
Não foi utilizada nenhuma estrutura de dados
customizada para facilitar essa checagem, como uma fila de prioridades. A busca
pelo processo de maior prioridade é feita de forma linear na lista de
processos, para facilitar a implementação.

\subsection{Chamadas de sistema}

Ao todo, quatro novas chamdas de sistema foram implementadas para facilitar o
desenvolvimento do trabalho, e o propósito de cada uma delas está desrito a
seguir.

\subsubsection{change\_prio()}

Conforme especificado no enunciado, a chamada de sistema
\textit{change\_prio()} deve ter utilizada para mudar
a prioridade do processo atual. Sua implementação é simples, e basta trafegar
por toda a lista de processos, encontrar o proesso com o identificador correto
e mudarsua prioridade conforme o parâmetro desejado.

\subsubsection{wait2()}

Conforme também especificado no enunciado, a chamada de sistema
\textit{wait2()} deve ser utilizada como uma
extensão da chamada de sistema \textit{wait()} mas com algumas ações a mais. Em
particular, ela deve também atribuir a três posições de memória os valores
totais de tempo que o processo passou nos estados \textit{READY},
\textit{RUNNING} e \textit{SLEEPING}, de modo que tais valores possam ser
utilizados posteriormente na análise de dados das modificações propostas para o
escalonador.

\subsubsection{yield2()}

A chamada de sustema \textit{yield2()} se trata apenas de uma solução paliativa
para que a função \textit{yield()} seja utilizada
nos programas do tipo S-CPU. Sem defini-lá, não era possível utiliar
\textit{yield()} em um programa de usuário pois não existia uma interface
definida para seu uso em espaço de usuário no \textit{kernel} do XV6.

Em suma, a chamada \textit{yield2()} apenas chama a função \textit{yield()}.

\subsubsection{set\_prio()}

A chamada de sistema \textit{set\_prio()} deve ser utilizada para modificar a
prioridade de um processo. Seu principal intuito é de ajudar nos testes do
escalonador e checar se ele está funcionando da forma que deveria.

Da maneira que interpretamos, uma boa forma de implementar o
\textit{set\_prio()} seria como uma extensão da chamada de sistema
\textit{fork()}, mas que permita a escolha dinâmica daprioridade do novo
processo criado. Dessa forma, sua implementação foi feita exatamente como uma
cópia de \textit{fork()}, mas a prioridade \(prio\) dos processos criados a
partir dela
não é 2 por padrão, mas seguem a seguinte equação a partir de seus próprios
identificadores \(pid\):

\[prio = (pid \mod 3) + 1\]

Portanto, um processo com identificador 15 teria prioridade 1, e um processo
com identificador 29 teria prioridae 3, por exemplo.

\subsection{Programas implementados}

Três tipos de programa deveriam ser criados para execuções no trabalho, sendo
eles
os programas \textit{CPU-Bound}, \textit{S-CPU} e \textit{IO-Bound}, e a
especificação de como cada um eles funciona está no enunciado.

Outros dois programas também foram implementados, sendo eles o progrma
\textit{sanity}, cujo objetivo é testar e analisar os tempos que cada processo
passou em cada estado, e um programa extra, que nós denominamos
\textit{myprogram}, cujo objetivo principal é testar o correto funcionamento do
novo escalonador. As especificações do programa \textit{sanity} estão definidas
no enunciado. Alguns detalhes relativos ao programa
\textit{myprogram}, no entanto, são detalhados abaixo.

\subsubsection{myprogram.c}

O programa chama, dentro de um \textit{loop} de tamanho 20, a chamada de
sistema \textit{set\_prio()}, que irá criar os novos processos e atribuir uma
prioridade a eles com base no identificador que receberem.
Após isso, o programa chama dentro de um laço \textit{while} a chamada de
sistema \textit{wait()} e, sempre que um de seus processos filhos finaliza,
imprime em tela seu identificador e sua prioridade inicial, isto é,prioridade
estabelecida no moment da criação.
O laço e o programa finalizam quando todos os processos filhos forem
finalizados.

\subsection{Mudança no intervalo de preempção}

Para alterar o intervalo de preempção, bastou alterar uma linha do arquivo
\textit{trap.c} e adicionar um campo à estrutura \textit{proc}. O novo campo,
denominado \textit{time\_slice}, é sempre inicializado com o valor de
\texttt{INTERV} quando um processo inicia sua execução na CPU, e contêm quantos
\textit{ticks} de \textit{clock} cada processo ainda tem.

No arquivo \textit{trap.c}, a preempção só ocorre quando o processo que está na
CPU tem um valor de \textit{time\_slice} igual a 0, ou seja, já esgotou o tempo
que tinha na CPU.

\section{Análise de resultados}

\subsection{Tempo médio em cada estado}

O tempo médio em cada estado é uma das formas de se compreender como cada um
dos tipos de processo (CPU-Bound, S-CPU e IO-Bound) se comportam dentro do
sistema. Para testar isso, utilizamos o programa \textit{sanity}. Abaixo,
podemos ver o resultado da execução do \textit{sanity} para 30 processos, isto
é, 10 processos de cada tipo.

POR EXEMPLO AQUI

\subsection{Escalonamento}

Para testar a nova política de escalonamento, conforme citado, foi utilizado o
programa \textit{myprogram}, que cria 20 processos do tipo
CPU-Bound, mas suas prioridades são estabelecidas conforme seus
identificadores. A tabela abaixo mostra a ordem de finalização dos processos
criados com base nisso.

\begin{table}[H]
      \centering
      \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Ordem de finalização} & \textbf{PID} & \textbf{Prioriade}
            \\
            \hline
            1                             & 5            & 3
            \\
            2                             & 8            & 3
            \\
            3                             & 11           & 3
            \\
            4                             & 14           & 3
            \\
            5                             & 17           & 3
            \\
            6                             & 20           & 3
            \\
            7                             & 23           & 3
            \\
            8                             & 4            & 2
            \\
            9                             & 7            & 2
            \\
            10                            & 10           & 2
            \\
            11                            & 13           & 2
            \\
            12                            & 16           & 2
            \\
            13                            & 19           & 2
            \\
            14                            & 22           & 2
            \\
            15                            & 6            & 1
            \\
            16                            & 9            & 1
            \\
            17                            & 12           & 1
            \\
            18                            & 15           & 1
            \\
            19                            & 18           & 1
            \\
            20                            & 21           & 1
            \\
            \hline
      \end{tabular}
      \caption{Ordem de finalizaçao - Fila multinível}
      \label{tab:indexedtable}
\end{table}

Podemos ver claramente que os processos foram finalizados na ordem correta,
isto é,aquele com a maior prioridade (3) finalizaram primeiro e, da mesma
maneira, aqueles com a menor prioridade (2) finalizaram por último. Isso traz
uma boa inclinação de que o escalonador está funcionando de maneira correta. A
título de comparação, temos abaixo uma tabela que foi gerada pelo mesmo código
de \textit{myprogram}, mas com o escalonador padrão do XV6.

\begin{table}[H]
      \centering
      \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Ordem de finalização} & \textbf{PID} & \textbf{Prioridade}
            \\
            \hline
            1                             & 4            & 2
            \\
            2                             & 5            & 3
            \\
            3                             & 6            & 1
            \\
            4                             & 7            & 2
            \\
            5                             & 8            & 3
            \\
            6                             & 9            & 1
            \\
            7                             & 10           & 2
            \\
            8                             & 11           & 3
            \\
            9                             & 12           & 1
            \\
            10                            & 13           & 2
            \\
            11                            & 14           & 3
            \\
            12                            & 15           & 1
            \\
            13                            & 16           & 2
            \\
            14                            & 17           & 3
            \\
            15                            & 18           & 1
            \\
            16                            & 19           & 2
            \\
            17                            & 20           & 3
            \\
            18                            & 21           & 1
            \\
            19                            & 22           & 2
            \\
            20                            & 23           & 3
            \\
            \hline
      \end{tabular}
      \caption{Ordem de finalização - Escalonador padrão}
      \label{tab:tabela_indexada}
\end{table}

Podemos ver que nesse caso, como a prioridade é ignorada, já que o escalonador
padrão do XV6 não leva ela em consideração, os processos são finalizados sem
considerar eles. Em particular, podemos ver que nesse caso os processos
finalizaram basicamente na ordme em que foram criados.

\textit{Tratamento de inanição}

\section{Conclusão}

Em suma, o segundo trabalho prática da disciplina
permitiu um aprendizado ainda mais aprofundado acerca de como um sistema
operacional funciona, uma vez que abriu portas para explorar, modificar e
analisar como um \textit{kernel} realmente é implementado.

Fazer as modificações próprias para alterar as políticas de escalonamento e
preempção tornaram a compreensão de como eles operam mais simples, e ampliaram
a visão de como um processo realmente é manipulado dentro do sistema.

\section{Referências}

\begin{itemize}
      \item Livros:
            \begin{itemize}
                  \item Tanenbaum, A. S. \& Bos, H. (2014), Modern Operating
                        Systems, Pearson, Boston, MA.
                  \item Abraham Silberschatz, Peter Baer Galvin, Greg Gagne:
                        Operating System Concepts, 10th Edition. Wiley 2018,
                        ISBN
                        978-1-118-06333-0
                  \item Arpaci-Dusseau, Remzi H., Arpaci-Dusseau, Andrea C..
                        (2014).
                        Operating systems: three easy pieces.: Arpaci-Dusseau
                        Books.
            \end{itemize}

      \item Web:
            \begin{itemize}
                  \item

                        \href{https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf}{\textit{xv6:
                                    a
                                    simple, Unix-like teaching operating
                                    system}}
            \end{itemize}

      \item Youtube:
            \begin{itemize}
                  \item \href{https://www.youtube.com/@JacobSorber}{Jacob
                              Sorber}
                  \item \href{https://www.youtube.com/@CodeVault}{Code Vault}
                  \item

                        \href{https://www.youtube.com/watch?v=fWUJKH0RNFE&list=PLbtzT1TYeoMhTPzyTZboW_j7TPAnjv9XB}{hhp3
                              xv6 \textit{kernel playlist}}
            \end{itemize}

\end{itemize}

\end{document}